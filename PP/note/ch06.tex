\chapter{ASCII 文本图形\label{ch06}}
\section{工作原理}
该项目利用了这样一个事实：从远处看，我们将灰度图像看成是它们亮度的平均值。

ASCII 文本图形的生成方法是，将图像分割成小块，并用 ASCII 字符替换一小块的平均 RGB 值。从远处看，因为眼睛的分辨率有限，我们大致会丢失细节，看到 ASCII 文本图形中的“平均”值，否则文本图形看起来就不那么真实。

该程序将给定的图像先转换为 8 位的灰度，让每个像素有一个灰度值，范围在 $[0,255]$（8 位整数的范围）。将这个 8 位值看成是亮度，0 表示黑色，255 表示白色，中间值是不同程度的灰色。

接着，将该图像分割成 $M\times N$ 个小块构成的网格（其中，$M$ 和 $N$ 是 ASCII 文本图形中的行和列编号）。然后程序计算网格中每个小块的平均亮度值，通过预定义的一些有梯度的 ASCII 字符（一组不断增加的值）来表示 $[0,255]$ 范围的灰度值，与适当的 ASCII 字符匹配。它将用这些值作为亮度值的查找表。

完成的 ASCII 文本图形只是一些文本行。要显示文本，就要用到 Courier 这样的等宽字体，因为如果每个文本字符宽度不相同，图像中字符将无法正确地按网格排列，会得到间隔不均和失真的输出。

所用字体的“横纵比”（宽度与高度之比）也会影响最终图像。如果一个字符所占空间的横纵比与该字符取代的图像小块的横纵比不同，则最终的 ASCII 字符图形会出现失真。实际上，你试图用一个 ASCII 字符来替换图像小块，所以它们的形状要匹配。例如，如果将图像分割成正方形小块，然后用一种高度拉伸的字体替换每个小块，最终的结果将出现垂直拉伸。

为了解决这个问题，需要缩放网格中的行数，以匹配 Courier 的长宽比。（可以向程序发送命令行参数，修改缩放，以匹配其他字体。）

总之，下面是程序生成 ASCII 文本图形的步骤：
\begin{enumerate}
    \item 将输入图像转成灰度；
    \item 将图像分成 $M\times N$ 个小块；
    \item 修正 $M$（行数），以匹配图像和字体的横纵比；
    \item 计算每个小块图像的平均亮度，然后为每个小块查找合适的 ASCII 字符；
    \item 汇集各行 ASCII 字符串，将它们打印到文件，形成最终图像。
\end{enumerate}