\chapter{读写文件\label{ch09}}
\section{文件与文件路径}
\subsection{Windows 上的倒斜杠以及 OS X 和 Linux 上的正斜杠}
在 Windows 上，路径书写使用倒斜杠作为文件夹之间的分隔符。但在 OS X 和 Linux 上，使用正斜杠作为它们的路径分隔符。如果想要程序运行在所有操作系统上，在编写 Python 脚本时，就必须处理这两种情况。

好在，用 os.path.join()函数来做这件事很简单。如果将单个文件和路径上的文件夹名称的字符串传递给它，os.path.join()就会返回一个文件路径的字符串，包含正确的路径分隔符。
\subsection{使用 / 运算符连接路径}
们通常用作除法的 / 运算符也可以组合 Path 对象和字符串。当你使用 Path() 函数创建路径对象后，这一点对修改路径对象很有帮助。

将 / 运算符与 Path 对象一起使用，连接路径就像连接字符串一样容易。与使用字符串连接或 join()方法相比，这个方法也更安全

Python 从左到右求值/运算符，并求值为一个 Path 对象，因此最左边第一个或第二个值必须是 Path 对象，整个表达式才能求值为 Path 对象。
\subsection{当前工作目录}
每个运行在计算机上的程序，都有一个“当前工作目录”，或 cwd。所有没有从根文件夹开始的文件名或路径，都假定在当前工作目录下。利用 Path.cwd()函数，可以取得当前工作路径的字符串，并可以利用 os.chdir()改变它。

如果要更改的当前工作目录不存在，Python 就会显示一个错误。

没有可以用于更改工作目录的 pathlib 函数，因为在程序运行时更改当前工作路径通常会导致微妙的错误。

os.getcwd() 是取得当前工作目录字符的较老方法。
\subsection{主目录}
所有用户在计算机上都有一个用于存放自己文件的文件夹，该文件夹称为“主目录”或“主文件夹”。可以通过调用 Path.home() 获得主文件夹的 Path 对象。
\subsection{绝对路径与相对路径}
有两种方法指定一个文件路径：
\begin{itemize}
    \item  “绝对路径”，总是从根文件夹开始。
    \item “相对路径”，它相对于程序的当前工作目录。
\end{itemize}
还有点（.）和点点（..）文件夹。它们不是真正的文件夹，而是可以在路径中使用的特殊名称。单个的句点（“点”）用作文件夹目名称时，是“这个目录”的缩写。两个句点（“点点”）意思是父文件夹。

\autoref{fig9-2} 是一些文件夹和文件的例子。
\figures{fig9-2}{在工作目录 C:\textbackslash bacon 中的文件夹和文件的相对路径}
\subsection{用 os.makedirs()创建新文件夹}
程序可以用 os.makedirs()函数创建新文件夹（目录）。os.makedirs()将创建所有必要的中间文件夹，目的是确保完整路径名存在。

要通过 Path 对象创建目录，请调用 mkdir()方法。注意，mkdir()一次只能创建一个目录。它不会像 os.makedirs()一样同时创建多个子目录。
\subsection{处理绝对路径和相对路径}
pathlib 模块提供了一些方法，用于检查给定路径是否为绝对路径，以及返回相对路径的绝对路径。

调用一个 Path 对象的\lstinline{is_absolute}方法，如果它代表绝对路径，则返回 True；如果代表相对路径，则返回 False。

要从相对路径获取绝对路径，可以将 Path.cwd() / 放在相对 Path 对象的前面。毕竟，当我们说“相对路径”时，几乎总是指相对于当前工作目录的路径。如果你的相对路径是相对于当前工作目录之外的其他路径，那么只需将 Path.cwd() 替换为那个其他路径就可以了。

os.path模块提供了一些有用的函数，它们与绝对路径和相对路径
有关。
\begin{itemize}
    \item 调用 os.path.abspath(path) 将返回参数的绝对路径的字符串。这是将相对路径转换为绝对路径的简便方法。
    \item 调用 os.path.isabs(path)，如果参数是一个绝对路径，就返回 True；如果参数是一个相对路径，就返回 False。
    \item 调用 os.path.relpath(path, start) 将返回从开始路径到 path 的相对路径的字符串。如果没有提供开始路径，就将当前工作目录作为开始路径。
\end{itemize}

\subsection{取得文件路径的各部分}
给定一个 Path 对象，可以利用 Path 对象的几个属性，将文件路径的不同部分提取为字符串。这对于在现有文件路径的基础上构造新文件路径很有用。这些属性如 \autoref{fig9-4} 所示。
\figures{fig9-4}{Windows 操作系统（上部）和 macOS/Linux 操作系统（下部）文件路径的部分}

文件路径的各个部分包括以下内容。
\begin{itemize}
    \item “锚点”（anchor），它是文件系统的根文件夹。
    \item 在 Windows 操作系统上，“驱动器”（drive）是单个字母，通常表示物理硬盘驱动器或其他存储设备。
    \item “父文件夹”（parent），即包含该文件的文件夹。
    \item “文件名”（name），由“主干名”（stem）（或“基本名称”）和“后缀名”（suffix）（或“扩展名”）构成。
\end{itemize}

parents 属性（与 parent 属性不同）求值为一组 Path 对象，代表祖先文件夹，具有整数索引。

较老的 os.path 模块也有类似的函数，用于取得写在一个字符串值中的路径的不同部分。调用 os.path.dirname(path) 将返回一个字符串，它包含 path 参数中最后一个斜杠之前的所有内容。调用 os.path.basename(path) 将返回一个字符串，它包含 path 参数中最后一个斜杠之后的所有内容。

如果同时需要一个路径的目录名称和基本名称，就可以调用 os.path.split()，获得这两个字符串的元组。

os.path.split()不会接收一个文件路径并返回每个文件夹的字符串的列表。如果需要这样，请使用 split() 字符串方法，并根据 os.sep 中的字符串进行分隔。（注意 sep 是在 os 中，不在 os.path 中。）针对运行程序的计算机，os.sep 变量被置为正确的目录分隔斜杠。

\figures{fig9-5}{基本名称跟在路径中最后一个斜杠后，它和文件名一样；目录名称是最后一个斜杠之前的所有内容}
\subsection{查看文件大小和文件夹内容}
os.path 模块提供了一些函数，用于查看文件的字节数以及给定文件夹中的文件和子文件夹。
\begin{itemize}
    \item 调用 os.path.getsize(path) 将返回 path 参数中文件的字节数。
    \item 调用 os.listdir(path) 将返回文件名字符串的列表，包含 path 参数中的每个文件（请注意，这个函数在 os 模块中，而不是在 os.path 中）。
\end{itemize}
\subsection{使用通配符模式修改文件列表}
如果要处理特定文件，那么使用 glob()方法比 listdir()更简单。Path 对象具有 glob()方法，用于根据“通配符（glob）模式”列出文件夹的内容。通配符模式类似于命令行命令中经常使用的正则表达式的简化形式。glob()方法返回一个生成器对象。

星号（*）代表“多个任意字符”，与星号不同，问号（?）代表任意单个字符。

通过选择具有特定属性的文件，glob()方法让你能够轻松地在目录中指定一些文件，并对其执行某些操作。
\subsection{检查路径的有效性}
Path 对象有一些方法来检查给定的路径是否存在，以及它是文件还是文件夹。假设变量 p 包含 Path 对象，那么可以预期会出现以下情况。

\begin{itemize}
    \item 如果该路径存在，调用 p.exists() 将返回True；否则返回 False。
    \item 如果该路径存在，并且是一个文件，调用 \verb|p.is_file()| 将返回 True；否则返回False。
    \item 如果该路径存在，并且是一个文件夹，调用 \verb|p.is_dir()| 将返回True；否则返回False。
\end{itemize}

较老的 os.path 模块可以使用 os.path.exists(path)、os.path.isfile (path) 和 os.path.isdir(path)函数来完成相同的任务，它们的行为与 Path 对象的函数类似。从 Python 3.6 开始，这些函数可以接收 Path 对象，也可以接收文件路径的字符串。
\section{文件读写过程}
\section{用shelve模块保存变量}
利用 shelve 模块，你可以将 Python 程序中的变量保存到二进制的 shelf 文件中。这样，程序就可以从硬盘中恢复变量的数据了。shelve 模块让你在程序中添加“保存”和“打开”功能。

要利用 shelve 模块读写数据，首先要导入它。调用函数 shelve.open()并传入一个文件名，然后将返回的值保存在一个变量中。可以对这个变量的 shelf 值进行修改，就像它是一个字典一样。当你完成时，在这个值上调用 close()。

你的程序稍后可以使用 shelve 模块，重新打开这些文件并取出数据。shelf 值不必用读模式或写模式打开，因为它们在打开后，既能读又能写。

就像字典一样，shelf 值有 keys()和 values()方法，返回 shelf 中键和值的类似列表的值。因为这些方法返回类似列表的值，而不是真正的列表，所以应该将它们传递给 list()函数，取得列表的形式。

创建文件时，如果你需要在 Notepad 或 TextEdit 这样的文本编辑器中读取它们，纯文本就非常有用。但是，如果想要保存 Python 程序中的数据，那就使用 shelve 模块。

\section{用 pprint.pformat()函数保存变量}
pprint.pprint()函数将列表或字典中的内容“漂亮打印”到屏幕，而 pprint.pformat()函数将返回同样的文本字符串，但不是打印它。这个字符串不仅是易于阅读的格式，同时也是语法上正确的 Python 代码。

import 语句导入的模块本身就是 Python 脚本。如果来自 pprint.pformat()的字符串保存为一个.py 文件，该文件就是一个可以导入的模块，像其他模块一样。

由于 Python 脚本本身也是带有.py 文件扩展名的文本文件，所以你的 Python 程序甚至可以生成其他 Python 程序。然后可以将这些文件导入到脚本中。

创建一个.py 文件（而不是利用 shelve 模块保存变量）的好处在于，因为它是一个文本文件，所以任何人都可以用一个简单的文本编辑器读取和修改该文件的内容。但是，对于大多数应用，利用 shelve 模块来保存数据，是将变量保存到文件的最佳方式。只有基本数据类型，诸如整型、浮点型、字符串、列表和字典，可以作为简单文本写入一个文件。例如，File 对象就不能够编码为文本。