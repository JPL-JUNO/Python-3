\chapter{作用域\label{ch17}}
\section{Python 作用域基础}
在代码中变量名被赋值的位置决定了这个变量名能被访问到的范围。

由于变量名最初没有声明，Python 将一个变量名被赋值的地点关联为（绑定给）一个特定的命名空间。换句话说，在代码中给一个变量赋值的地方决定了这个变量将存在于哪个命名空间，也就是它可见的范围。

除打包代码之外，函数还为程序增加了一个额外的命名空间层：在默认的情况下，一个函数的所有变量名都是与函数的命名空间相关联的。这意味着：
\begin{itemize}
    \item 一个在 def 内定义的变量名能够被 def 内的代码使用。不能在函数的外部引用这样的变量名。
    \item def 之中的变量名与 def 之外的变量名并不冲突，即使是使用在别处的相同的变量名。
\end{itemize}

分别对应3种不同的作用域：
\begin{itemize}
    \item 如果一个变量在 def 内赋值，它被定位在这个函数之内。
    \item 如果一个变量在一个外层的 def 中赋值，对于内层的函数来说，它是非局部的。
    \item 如果在 def 之外赋值，它就是整个文件全局的。
\end{itemize}
\subsection{作用域细节}
从技术上讲，交互式命令行是一个名为 \_\_main\_\_ 的模块，它可以打印结果，但不会保存其代码；不过在其他方面，它都与模块文件的顶层相同。

函数定义了局部作用域，而模块定义的是全局作用域：
\begin{description}
    \item[外围模块是全局作用域]每个模块都是一个全局作用域（也就是说，一个创建于模块文件顶层的变量的命名空间）。在模块被导入后，相对于外部世界而言全局变量就成为一个模块对象的属性，但是在一个模块中能够像简单的变量一样使用。
    \item[全局作用域的作用范围仅限于单个文件]别被这里的“全局”所迷惑，这里的全局指的是在一个文件的顶层的变量名仅对于这个文件内部的代码而言是全局的。在 Python 中是没有基于一个单个的、无所不包的情景文件的全局作用域的。替代这种方法的是，变量名由模块文件隔开，并且必须精确地导入一个模块文件才能够使用这个文件中定义的变量名。当你在 Python 中听到“全局的”，你就应该想到“模块”。
    \item[赋值的变量名除非被声明为 global 或 nonlocal，否则均为局部变量。]在默认情况下，所有函数定义内的变量是位于局部作用域（与函数调用相关的）内的。如果您需要分配一个位于包含该函数的模块顶层的名称，您可以通过在函数内部的全局语句中声明它来实现。 如果您需要分配一个位于封闭 def 中的名称，从 Python 3.X 开始，您可以通过在非局部语句中声明它来实现。
    \item[所有其他的变量名都可以归纳为局部、全局或者内置的。]在函数定义内部的尚未赋值的变量名是一个在一定范围内（在这个 def 内部）的局部变量、全局（在一个模块的命名空间内部）或者内置（由 Python 的预定义模块提供的）变量。\textcolor{red}{我有点没看太明白。}
    \item[每次对函数的调用都创建了一个新的局部作用域。]每次调用函数，都创建了一个新的局部作用域。也就是说，将会存在由那个函数创建的变量的命名空间。可以认为每一个 def 语句（以及 lambda 表达式）都定义了一个新的局部作用域，但是因为 Python 允许函数在循环中调用自身（一种叫做递归的高级技术），所以从技术上讲，局部作用域实际上对应的是函数的调用。换句话说，每一个函数调用都创建了一个新的局部命名空间。递归在处理不能提前预知的流程结构时是一个有用工具。
\end{description}

还要注意，一个函数内部的任何类型的赋值都会把一个名称划定为局部的。这包括 = 语句、import 中的模块名称、def 中的函数名称、函数参数名称等。如果在一个def 中以任何方式赋值一个名称，它都将对于该函数成为局部的。

此外，\textcolor{red}{注意就地改变对象（in-place changes）并不会把变量划分为局部变量，实际上只有对变量名赋值才可以。}例如，如果变量名 L 在模块的顶层被赋值为一个列表，在函数内部的像 L.append(X) 这样的语句并不会将 L 划分为局部变量，而 L = X 却可以。通常，记住名称和对象之间的清楚的区分是有帮助的：修改一个对象并不是对一个名称赋值。
\subsection{变量名解析：LEGB 原则}
对于一个 def 语句：
\begin{itemize}
    \item 变量名引用分为三个作用域进行查找：首先是局部，之后是函数内（如果有的话），之后全局，最后是内置。
    \item 在默认情况下，变量名赋值会创建或者改变局部变量。
    \item 全局声明和非局部声明将赋值的变量名映射到模块文件内部的作用域。换句话说，所有在函数 def 语句（或者 lambda，我们稍后会学习的一个表达式）内赋值的变量名默认均为局部变量。函数能够在函数内部以及全局作用域(也就是物理上)直接使用变量名，但是必须声明为非局部变量和全局变量去改变其属性。
\end{itemize}

Python 的变量名解析机制有时称为 LEGB 法则，这也是由作用域的命令而来的。
\begin{itemize}
    \item 当在函数中使用未认证的变量名时，Python 搜索 4 个作用域[本地作用域（L），之后是上一层结构中 def 或 lambda 的本地作用域（E），之后是全局作用域（G），最后是内置作用域（B）]并且在第一处能够找到这个变量名的地方停下来。如果变量名在这次搜索中没有找到，Python 会报错。变量名在使用前首先必须赋值过。
    \item 当在函数中给一个变量名赋值时（而不是在一个表达式中对其进行引用），Python 总是创建或改变本地作用域的变量名，除非它已经在那个函数中声明为全局变量。
    \item 当在函数之外给一个变量名赋值时（也就是，在一个模块文件的顶层，或者是在交互提示模式下），本地作用域与全局作用域（这个模块的命名空间）是相同的。
\end{itemize}

\autoref{fig17-1} 描述了 Python 的四个作用域的关系。注意到第二个 E 作用域的查找层次（上层 def 和 lambda 的作用域）从技术上来说可能不仅是一层查找的层次。当你在函数中嵌套函数时这个层次才需要考虑。

\figures{fig17-1}{LEGB 作用域查找原则。当引用一个变量时，Python 按以下顺序依次进行查找：从局部变量中，在任意上层函数的作用域，在全局作用域，最后在内置作用域中查找。第一个能够完成查找的就算成功。变量在代码中被赋值的位置通常就决定了它的作用域。在 Python 3.X 中，nonlocal 声明也可以迫使名称映射到函数内部的作用域中，而不管是否对其赋值。}

此外，记住这些规则仅对简单的变量名有效（例如，spam）。在 \autoref{p5} 和 \autoref{p6} 中，我们将会看到被验证的属性变量名（例如，object.spam）会存在于特定的对象中，并遵循一种完全不同的查找规则，而不止我们这里提到的作用域的概念。属性引用（变量名跟着点号）搜索一个或多个对象，而不是作用域，并且有可能涉及所谓的“继承”的概念（将在 \autoref{p6} 讨论）。
\subsection{内置作用域}
实际上，内置作用域仅仅是一个名为 builtins 的内置模块，但是必须要导入 builtins 之后才能使用内置作用域，因为变量名 builtins 本身并没有预先内置。

3.X 内置作用域是通过一个名为 builtins 的标准库模块来实现的，但是这个变量名自身并没有放入内置作用域内，所以必须导入这个文件才能够使用它。

两种方法引用一个内置函数：通过 LEBG 法则带来的好处，或者手动导入 builtins 模块。
\subsubsection*{重定义内置名称：有好有坏}
有时在高级编程中你可能真的想要在自己的代码中重定义内置名称来替换原有的名称。然而，重定义一个内置名称往往是个错误。并且让人头疼的是，Python 对于这个问题不会处理为警告信息。

\section{global 语句}
global 语句和它的 3.X 近亲 nonlocal 语句是 Python 中唯一看起来有些像声明语句的语句。但是，它并不是一个类型或大小的声明，它是一个命名空间的声明。它告诉 Python 函数打算生成一个或多个全局变量名。也就是说，存在于整个模块内部作用域（命名空间）的变量名。
\begin{itemize}
    \item 全局变量是在外层模块文件的顶层被赋值的变量名。
    \item \textbf{全局变量如果是在函数内被赋值的话，必须经过声明。}
    \item \textbf{全局变量名在函数的内部不经过声明也可以被引用。}
\end{itemize}

换句话说，global 允许我们修改一个 def 之外的模块文件的顶层的名称。global 语句包含了关键字 global，其后跟着一个或多个由逗号分开的变量名。当在函数主体被赋值或引用时，所有列出来的变量名将被映射到整个模块的作用域内。
\subsection{程序设计：最小化全局变量}
一般而言，函数应该依赖形参与返回值而不是全局变量。
\subsection{程序设计：最小化跨文件的修改}
尽管能直接修改另一个文件中的变量，但是往往我们都不这样做。在文件间进行通信最好的办法就是通过调用函数，传递参数，然后得到其返回值。
\section{作用域和嵌套函数}
\subsection{嵌套作用域的细节}
在增加了嵌套的函数作用域后，变量的查找法则变得稍微复杂了一些。
对于一个函数：
\begin{itemize}
    \item 一个引用（X）首先在本地（函数内）作用域查找变量名 X；之后会在代码的语法上嵌套了的函数中的本地作用域，从内到外查找；之后查找当前的全局作用域（模块文件）；最后再内置作用域内。全局声明将会直接从全局（模块文件）作用域进行搜索。
    \item 在默认情况下，一个赋值（X = value）创建或改变了变量名 X 的当前作用域。如果 X 在函数内部声明为全局变量，它将会创建或改变变量名 X 为整个模块的作用域。另一方面，如果 X 在函数内声明为 nonlocal，赋值会修改最近的嵌套函数的本地作用域中的名称 X。
\end{itemize}
注意：全局声明将会将变量映射至整个模块。当嵌套函数存在时，嵌套函数中的变量也许仅仅是引用，但它们需要 nonlocal 声明才能修改。
\subsection{工厂函数：闭包}
根据要求的对象，这种行为有时也叫做闭合（closure）或者工厂函数（factory function）——一个能够记住嵌套作用域的变量值的函数，尽管那个作用域或许已经不存在了。
\subsubsection*{一个简单的函数工厂}
工厂函数（也称为闭包）有时被需要动态生成事件处理程序以响应运行时条件的程序使用。 例如，想象一个 GUI 必须根据用户输入定义操作，而这些操作在 GUI 构建时是无法预料的。 在这种情况下，我们需要一个函数来创建并返回另一个函数，其中的信息可能因每个函数而异。
\subsubsection*{闭包 vs 类：回合 1}
对于某些人来说，\autoref{p6} 中完整描述的类可能看起来更擅长像这样的状态保留，因为它们通过属性分配使它们的记忆更加明确。类还直接支持闭包函数不支持的附加工具，例如通过继承和运算符重载进行定制，并且更自然地以方法的形式实现多种行为。由于这些区别，类可能更擅长实现更完整的对象。

尽管如此，当保留状态是唯一目标时，闭包函数通常提供更轻量级且可行的替代方案。它们为单个嵌套函数所需的数据提供每次调用的本地化存储。当我们添加前面描述的 3.X 非局部语句以允许封闭作用域状态更改时尤其如此（在 2.X 中，封闭作用域是只读的，因此用途更有限）。

从更广泛的角度来看，Python 函数有多种方法可以在调用之间保留状态。虽然普通局部变量的值在函数返回时消失，但全局变量的值可以在调用过程中保留；在类实例属性中；在我们在这里遇到的封闭范围参考中；以及参数默认值和函数属性。有些可能也在此列表中包含可变的默认参数（尽管其他人可能希望他们不这样做）。
\subsection{使用默认参数来保留嵌套作用域的状态}
最好的处方就是简单地避免在 def 中嵌套 def，这会让程序更加得简单---在 Python 的世界观里，扁平通常胜于嵌套。
\subsubsection*{嵌套作用域，默认值参数和 lambda}
lambda，简短地说，它就是一个表达式，将会生成后面调用的一个新的函数，与 def 语句很相似。由于它是一个表达式，尽管能够使用在 def 中不能使用的地方，例如，在一个列表或是字典常量之中。

像 def 一样，lambda 表达式引入了新的本地作用域。多亏了嵌套作用域查找层，lambda 能够看到所有在其所编写的函数中可用的变量。

由于 lambda 是表达式，所以它们自然而然地（或者更一般的）嵌套在了 def 中。因此，它们也就成为了后来在查找原则中增补嵌套函数作用域的最大受益者。在大多数情况下，给 lambda 函数通过默认参数传递值也就没有什么必要了。

\subsubsection*{循环变量可能需要默认值参数，而不是作用域}
如果在函数中定义的 lambda 或者 def 嵌套在一个循环之中，而这个内嵌函数友引用了一个外层作用域的变量，该变量被循环所改变，那么所有在这个循环中产生的函数会有相同的值---也就是在最后一次循环中完成时被引用变量的值。
\begin{tcolorbox}
    因为嵌套作用域中的变量在嵌套的函数被调用时才进行查找，所以它们实际上记住的是同样的值（在最后一次循环迭代中循环变量的值）。
\end{tcolorbox}

这是在嵌套作用域的值和默认参数方面遗留的一种仍需要解释清楚的情况，而不是引用所在的嵌套作用域的值。也就是说，为了让这类代码能够工作，必须使用默认参数把当前的值传递给嵌套作用域的变量。因为默认参数是在嵌套函数创建时评估的（而不是在其稍后调用时）。

\subsubsection*{任意的作用域嵌套}
我们要主要作用域可以做任意的嵌套，但是当名称被引用时指挥查找外层函数 def 语句（而不是类）。
\section{Python 3.X 中的 nonlocal 语句}
我们们介绍了嵌套函数可以引用一个嵌套的函数作用域中的变量的方法，即便这个函数已经返回了。事实上，在 Python 3.X 中，我们也可以修改这样的嵌套作用域变量，只要我们在一条 nonlocal 语句中声明它们。使用这条语句，嵌套的 def 可以对嵌套函数中的名称进行读取和写入访问。

nonlocal 语句是 global 的近亲，前面已经介绍过 global。nonlocal 和 global 一样，声明了将要在一个嵌套的作用域中修改的名称。和 global 的不同之处在于，nonlocal 应用于一个嵌套的函数的作用域中的一个名称，而不是所有 def 之外的全局模块作用域；而且在声明 nonlocal 名称的时候，它必须已经存在于该嵌套函数的作用域中——它们可能只存在于一个嵌套的函数中，并且不能由一个嵌套的 def 中的第一次赋值创建。

换句话说，nonlocal 即允许对嵌套的函数作用域中的名称赋值，并且把这样的名称的作用域查找限制在嵌套的 def。直接效果是更加直接和可靠地实现了可更改的作用域信息，对于那些不想要或不需要带有属性的类的程序而言。
\subsection{nonlocal 基础}
Python 3.X 引入了一条新的 nonlocal 语句，它只在一个函数内有意义：
\begin{verbatim}
    def func():
        nonlocal name1, name2
\end{verbatim}

nonlocal 语句除了允许修改外层 def 中的名称外，还会强制发起引用，这点很想 global 语句，nonlocal 是的对该语句中列出的名称的查找从外层的 def 作用域开始，而不是该函数本身的作用域，也就是说，nonlocal 意味着完全略过我的局部作用域。

实际上，当执行到 nonlocal 语句的时候，nonlocal 中列出的名称必须在一个嵌套的 def 中提前声明过，否则，将会产生一个错误。

当在一个函数中使用的时候，global 和 nonlocal 语句都在某种程度上限制了查找规则：
\begin{itemize}
    \item global 使得作用域查找从嵌套的模块的作用域开始，并且允许对那里的名称赋值。如果名称不存在于该模块中，作用域查找继续到内置作用域，但是，对全局名称的赋值总是在模块的作用域中创建或修改它们。
    \item nonlocal 限制作用域查找只是嵌套的 def，要求名称已经存在于那里，并且允许对它们赋值。作用域查找不会继续到全局或内置作用域。
\end{itemize}
\subsubsection*{边界情况}
有几件事情需要注意。首先，和 global 语句不同，当执行一条 nonlocal 语句时，nonlocal 名称必须已经在一个嵌套的 def 作用域中赋值过，否则将会得到一个错误——不能通过在嵌套的作用域中赋给它们一个新值来创建它们。事实上，nonlocal 名称在外层或内嵌函数被调用之前就已经在函数定义的时候被检查了。 其次，nonlocal 限制作用域查找仅为嵌套的 def，nonlocal 不会在嵌套的模块的全局作用域或所有 def 之外的内置作用域中查找，即便已经有了这些作用域。
\section{为什么使用 nonlocal？状态保持备选项}
在很多程序中，状态信息变得很重要。在 Python 中，有各种不同的方法来“记住”跨函数和方法的信息。尽管都有利有弊，对于嵌套的作用域引用，nonlocal 确实起到了改进作用——nonlocal 语句允许在内存中保持可变状态的多个副本，并且解决了在类无法保证的情况下的简单的状态保持。

