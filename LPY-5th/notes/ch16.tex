\chapter{函数基础\label{ch16}}
简而言之，一个函数就是将一些语句集合在一起的部件，它们能够不止一次地在程序中运行。函数还能够计算出一个返回值，并能够改变作为函数输入的参数，而这些参数在代码运行时也许每次都不相同。

更具体地说，函数是在编程过程中剪剪贴贴的替代——我们不再有一个操作的代码的多个冗余副本，而是将代码包含到一个单独的函数中。通过这样做，我们可以大大减少今后的工作：如果这个操作之后必须要修改，我们只需要修改其中的一份拷贝，而不是所有代码。

函数是 Python 为了代码最大程度的重用和最小化代码冗余而提供的最基本的程序结构。

我们将学习与函数相关的主要语句和表达式，其中包含了函数调用语句、两种声明函数的方式（def 和 lambda）、两种管理作用域的方式（global 和 nonlocal），以及两种传回返回值的方式（return 和 yield）。
\section{编写函数}
下面是一个关于Python函数背后的一些主要概念的简要介绍：
\begin{itemize}
    \item def 是可执行的代码。Python 的函数是由一个新的语句编写的，即 def。不像 C 这样的编译语言，def 是一个可执行的语句——函数并不存在，直到 Python 运行了 def 后才存在。事实上，在 if 语句、while 循环甚至是其他的 def 中嵌套是合法的（甚至在某些场合还很有效）。在典型的操作中，def语句在模块文件中编写，并自然而然地在模块文件第一次被导入的时候生成定义的函数。
    \item def 创建了一个对象并将其赋值给某一变量名。当 Python 运行到 def 语句时，它将会生成一个新的函数对象并将其赋值给这个函数名。就像所有的赋值一样，函数名变成了某一个函数的引用。函数名其实并没有什么神奇——就像你将看到的那样，函数对象可以赋值给其他的变量名，保存在列表之中。
    \item lambda 创建一个对象但将其作为结果返回。也可以用 lambda 表达式创建函数，这一功能允许我们把函数定义内联到语法上一条def语句不能工作的地方（这是一个更加高级的概念，我们推迟到 \autoref{ch19} 介绍）。
    \item return 将一个结果对象发送给调用者。当函数被调用时，其调用者停止运行直到这个函数完成了它的工作，之后函数才将控制权返回调用者。函数是通过 return 语句将计算得到的值传递给调用者的，返回值成为函数调用的结果。
    \item yield 向调用者发回一个结果对象，但是记住它离开的地方。像生成器这样的函数也可以通过 yield 语句来返回值，并挂起它们的状态以便稍后能够恢复状态。这是本书稍后要介绍的另一个高级话题。
    \item global 声明了一个模块级的变量并被赋值。在默认情况下，所有在一个函数中被赋值的对象，是这个函数的本地变量，并且仅在这个函数运行的过程中存在。为了分配一个可以在整个模块中都可以使用的变量名，函数需要在 global 语句中将它列举出来。通常情况下，变量名往往需要关注它的作用域（也就是说变量存储的地方），并且是通过实赋值语句将变量名绑定至作用域的。
    \item nonlocal 声明了将要赋值的一个封闭的函数变量。类似的，Python 3.X 中添加的 nonlocal 语句允许一个函数来赋值一条语法封闭的 def 语句的作用域中已有的名称。这就允许封闭的函数作为保留状态的一个地方——当一个函数调用的时候，信息被记住了——而不必使用共享的全局名称。
    \item 函数是通过赋值（对象引用）传递的。在 Python 中，参数通过赋值传递给了函数（也就是说，就像我们所学过的，使用对象引用）。正如你将看到的那样，Python 的模式中，调用者以及函数通过引用共享对象，但是不需要别名。改变函数中的参数名并不会改变调用者中的变量名，但是改变传递的可变对象可以改变调用者共享的那个对象。
    \item 除非你显式指明形式参数与实际参数的对应，否则实际参数按位置赋值给形式参数。
    \item 参数、返回值以及变量不需要被声明。
\end{itemize}
def 语句将创建一个函数对象并将其赋值给一个变量名。def 语句一般的格式如下所示：
\begin{verbatim}
    def name(arg1, arg2,... argN):
        statements
\end{verbatim}

函数体通常包含一条 return 语句：
\begin{verbatim}
    def name(arg1, arg2,... argN):
        ...
        return value
\end{verbatim}

Python 的 return 语句可以在函数主体中的任何地方出现。它表示函数调用的结束，并将结果返回至函数调用处。return 语句包含一个对象表达式，这个对象给出的函数的结果。return 语句是可选的。如果它没有出现，那么函数将会在控制流执行完函数主体时结束。从技术角度来讲，一个没有返回值的函数自动返回了 None 对象，但是这个值是往往被忽略掉的。

函数也许会有 yield 语句，这在每次都会产生一系列值时被用到，这在 \autoref{ch20} 我们研究函数的高级话题时才会讨论到。
\subsection{def 语句执行于运行时}
Python 的 def 语句实际上是一个可执行的语句：当它运行的时候，它创建一个新的函数对象并将其赋值给一个变量名。（请记住，Python 中所有的语句都是实时运行的，没有像独立的编译时间这样的流程）。

因为函数定义是实时发生的，所以对于函数名来说并没有什么特别之处。关键之处在于函数名所引用的那个对象。
\section{第一个例子：定义和调用}
\subsection{Python 中的多态}
Python 将对某一对象在某种语法的合理性交由对象自身来判断。这种依赖类型的行为称为多态，其含义就是一个操作的意义取决于被操作对象的类型。因为 Python 是动态类型语言，所以多态在 Python 中随处可见。

在 Python 中，代码不应该关心特定的数据类型。如果不是这样，那么代码将只对编写时你所关心的那些类型有效，对以后的那些可能会编写的兼容对象类型并不支持，这样做会打乱代码的灵活性。大体上来说，我们在 Python 中为对象编写接口，而不是数据类型\footnote{鸭子类型，其核心思想是，你的代码不必在意一个对象是不是一只鸭子，只需要关心它能像鸭子那样叫。不管是不是鸭子，只要能叫就行，同时鸭子叫的实现留给对象自己来完成。}。
\subsection{局部变量}
所有的在函数内部进行赋值的变量名都默认为局部变量。所有的局部变量都会在函数调用时出现，并在函数退出时消失。正因如此，一个函数的变量不会在两次调用期间记忆值；尽管一个函数返回的对象将继续存在，保存其他状态的信息则需要另外的技术。