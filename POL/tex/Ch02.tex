\chapter{Python Tricks\label{Ch02}}
\section{Using List Comprehension to Find Top Earners}

\section{Reading a File}
To access files on your computer, you need to know how to open and close files. You can access a file's data only after you've opened it. After closing the file, you can be sure that the data was written into the file. Python may create a buffer and wait for a while before it writes the whole buffer into the file (Figure 2-1). The reason for this is simple: file access is slow.

For efficiency reasons, Python avoids writing every single bit independently. Instead, it waits until the buffer has filled with enough bytes and then flushes the whole buffer at once into the file.

\figures{fig2-1}{Opening and closing a file in Python}
That's why it's good practice to close the file after reading it with the
command f.close(), to ensure all the data is properly written into the file
instead of residing in temporary memory. However, in a few exceptions,
Python closes the file automatically: one of these exceptions occurs when
the reference count drops to zero.

\section{Using Lambda and Map Functions}
You can use lambda functions to define a simple function with a return value (the return value can be any object, including tuples, lists, and sets). In other words, every lambda function returns an object value to its calling environment. \important{Note that this poses a practical restriction to lambda functions, because unlike standard functions, they are not designed to execute code without returning an object value to the calling environment.}

\tcbox{
    \textsf{lambda arguments : return expression}
}

You start the function definition with the keyword lambda, followed by a sequence of function arguments. When calling the function, the caller must provide these arguments. You then include a colon (:) and the return expression, which calculates the return value based on the arguments of the lambda function. The return expression calculates the function output and can be any Python expression.

One common example is using lambda with the map() function that takes as input arguments a function object f and a sequence s. The map() function then applies the function f on each element in the sequence s.
\section{Using Slicing to Extract Matching Substring Environments}

\tcbox{\textsf{x[start:stop:step]}}
These variants of the basic \textsf{[start:stop:step]} pattern of Python slicing
highlight the technique’s many interesting properties:
\begin{itemize}
    \item If start $>=$ stop with a positive step size, the slice is empty.
    \item If the stop argument is larger than the sequence length, Python will slice all the way to and including the rightmost element.
    \item If the step size is positive, the default start is the leftmost element, and the default stop is the rightmost element (included).
    \item If the step size is negative (step $<$ 0), the slice traverses the sequence in reverse order. With empty start and stop arguments, you slice from the rightmost element (included) to the leftmost element (included). Note that if the stop argument is given, the respective position is excluded from the slice.
\end{itemize}

\section{Combining List Comprehension and Slicing}

\section{Using Slice Assignment to Correct Corrupted Lists}
Slice assignments use slicing notation on the left-hand side of an assignment operation to modify a subsequence of the original sequence.

You’ll use slice assignments to select and replace a sequence of elements between indices i and j by using the slicing notation lst[i:j] = [0 0 ...0]. Because you are using slicing lst[i:j] on the left-hand side of the assignment operation (rather than on the right-hand side as done previously), the feature is denoted as slice assignments.

The idea of slice assignments is simple: replace all selected elements in
the original sequence on the left with the elements on the right.

\section{Analyzing Cardiac Health Data with List Concatenation}
You’ll combine slicing with the new Python feature list concatenation, which creates a new list by concatenating (that is, joining) existing lists.