\chapter{迭代器和生成器\label{ch04}}
如果一个函数定义中包含 yield 表达式，那么这个函数就不再是一个普通函数，而是一个生成器函数。yield 语句类似 return 会返回一个值但它会记住这个返回的位置，下次 next() 迭代就从这个位置下一行继续执行。生成器函数并不是生成器，它运行返回后的结果才是生成器。
\section{手动访问迭代器中的元素}
我们需要处理某个可迭代对象中的元素，但是基于某种原因不能也不想使用 for 循环。要手动访问可迭代对象中的元素，可以使用 next()函数，然后自己编写代码来捕获 StopIteration 异常。一般来说，StopIteration 异常是用来通知我们迭代结束的。但是，如果是手动使用 next()，也可以命令它返回一个结束值，比如说 None。

\section{委托迭代}
Python 的迭代协议要求\verb|__iter__()|返回一个特殊的迭代器对象，由该对象实现的\verb|__next__()|方法来完成实际的迭代。如果要做的只是迭代另一个容器中的内容，我们不必担心底层细节是如何工作的，所要做的就是转发迭代请求。
\section{用生成器创建新的迭代模式}
如果想实现一种新的迭代模式，可使用生成器函数来定义。函数中只要出现了 yield 语句就会将其转变成一个生成器。与普通函数不同，生成器只会在响应迭代操作时才运行。
\section{实现迭代协议}
Python 的迭代协议要求\verb|__iter__()|返回一个特殊的迭代器对象，该对象必须实现\verb|__next__()|方法，并使用 StopIteration 异常来通知迭代的完成。
\section{反向迭代}
可以使用内建的 reversed()函数实现反向迭代。反向迭代只有在待处理的对象拥有可确定的大小，或者对象实现了\verb|__reversed__()|特殊方法时，才能奏效。如果这两个条件都无法满足，则必须首先将这个对象转换为列表。许多程序员都没有意识到如果他们实现了\verb|__reversed__()|方法，那么就可以在自定义的类上实现反向迭代。定义一个反向迭代器可使代码变得更加高效，因为这样就无需先把数据放到列表中，然后再反向去迭代列表了。
\section{定义带有额外状态的生成器函数}
如果想让生成器将状态暴露给用户，别忘了可以轻易地将其实现为一个类，然后把生成器函数的代码放到\verb|__iter__()|方法中即可。
\section{对迭代器做切片操作}
我们想对由迭代器产生的数据做切片处理，但是普通的切片操作符在这里不管用。要对迭代器和生成器做切片操作，itertools.islice()函数是完美的选择。

迭代器和生成器是没法执行普通的切片操作的，这是因为不知道它们的长度是多少（而且它们也没有实现索引）。islice()产生的结果是一个迭代器，它可以产生出所需要的切片元素，但这是通过访问并丢弃所有起始索引之前的元素来实现的。之后的元素会由 islice 对象产生出来，直到到达结束索引为止。
\section{跳过可迭代对象中的前一部分元素}
我们想对某个可迭代对象做迭代处理，但是对于前面几个元素并不感兴趣，只想将它们丢弃掉。itertools 模块中有一些函数可用来解决这个问题。第一个是 itertools.dropwhile()函数。要使用它，只要提供一个函数和一个可迭代对象即可。该函数返回的迭代器会丢弃掉序列中的前面几个元素，只要它们在所提供的函数中返回 True 即可。这之后，序列中剩余的全部元素都会产生出来。如果恰好知道要跳过多少个元素，那么可以使用 itertools.islice()。
\section{迭代所有可能的组合或排列}
为了解决这个问题，itertools 模块中提供了 3 个函数。

第一个是 itertools.permutations()—它接受一个元素集合，将其中所有的元素重排列为所有可能的情况，并以元组序列的形式返回（即，将元素之间的顺序打乱成所有可能的情况）。如果想得到较短长度的所有全排列，可以提供一个可选的长度参数。

使用 itertools.combinations()可产生输入序列中所有元素的全部组合形式。当产生组合时，已经选择过的元素将从可能的候选元素中移除掉（即，如果'a'已经选过了，那么就将它从考虑范围中去掉）。\verb|itertools.combinations_with_replacement()|函数解放了这一限制，允许相同的元素得到多次选择。
\section{以索引-值对的形式迭代序列}
我们想迭代一个序列，但是又想记录下序列中当前处理到的元素索引。内建的 enumerate()函数可以非常漂亮地解决这个问题。

如果要打印出规范的行号（这种情况下一般是从 1 开始而不是 0），可以传入一个 start 参数作为起始索引。

enumerate()的返回值是一个 enumerate 对象实例，它是一个迭代器，可返回连续的元组。元组由一个索引值和对传入的序列调用 next()而得到的值组成。
\section{同时迭代多个序列}
可以使用 zip()函数来同时迭代多个序列。
\section{在不同的容器中进行迭代}
我们需要对许多对象执行相同的操作，但是这些对象包含在不同的容器内，而我们希望可以避免写出嵌套的循环处理，保持代码的可读性。

itertools.chain()方法可以用来简化这个任务。它接受一系列可迭代对象作为输入并返回一个迭代器，这个迭代器能够有效地掩盖一个事实—你实际上是在对多个容器进行迭代。

在程序中，chain()常见的用途是想一次性对所有的元素执行某项特定的操作，但是这些元素分散在不同的集合中。

itertools.chain()可接受一个或多个可迭代对象作为参数，然后它会创建一个迭代器，该迭代器可连续访问并返回你提供的每个可迭代对象中的元素。尽管区别很小，但是chain()比首先将各个序列合并在一起然后再迭代要更加高效。
\section{}
\section{}
\section{}
\section{}