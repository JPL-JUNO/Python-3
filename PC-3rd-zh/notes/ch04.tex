\chapter{迭代器和生成器\label{ch04}}
\section{手动访问迭代器中的元素}
我们需要处理某个可迭代对象中的元素，但是基于某种原因不能也不想使用 for 循环。要手动访问可迭代对象中的元素，可以使用 next()函数，然后自己编写代码来捕获 StopIteration 异常。一般来说，StopIteration 异常是用来通知我们迭代结束的。但是，如果是手动使用 next()，也可以命令它返回一个结束值，比如说 None。

\section{委托迭代}
Python 的迭代协议要求\verb|__iter__()|返回一个特殊的迭代器对象，由该对象实现的__next__()方法来完成实际的迭代。如果要做的只是迭代另一个容器中的内容，我们不必担心底层细节是如何工作的，所要做的就是转发迭代请求。
\section{用生成器创建新的迭代模式}
如果想实现一种新的迭代模式，可使用生成器函数来定义。函数中只要出现了 yield 语句就会将其转变成一个生成器。与普通函数不同，生成器只会在响应迭代操作时才运行。
\section{实现迭代协议}
Python 的迭代协议要求\verb|__iter__()|返回一个特殊的迭代器对象，该对象必须实现__next__()方法，并使用 StopIteration 异常来通知迭代的完成。
\section{反向迭代}
可以使用内建的 reversed()函数实现反向迭代。反向迭代只有在待处理的对象拥有可确定的大小，或者对象实现了\verb|__reversed__()|特殊方法时，才能奏效。如果这两个条件都无法满足，则必须首先将这个对象转换为列表。许多程序员都没有意识到如果他们实现了\verb|__reversed__()|方法，那么就可以在自定义的类上实现反向迭代。定义一个反向迭代器可使代码变得更加高效，因为这样就无需先把数据放到列表中，然后再反向去迭代列表了。
\section{定义带有额外状态的生成器函数}
如果想让生成器将状态暴露给用户，别忘了可以轻易地将其实现为一个类，然后把生成器函数的代码放到\verb|__iter__()|方法中即可。
\section{}
\section{}
\section{}
\section{}
\section{}
\section{}
\section{}
\section{}
\section{}
\section{}
\section{}
\section{}
\section{}
\section{}
\section{}
\section{}
\section{}
\section{}
\section{}
\section{}