# 函数

程序员在 Python 中使用的第一个组织工具是**函数**（function）。

## [第 19 项：当函数返回多个值时，切勿拆分三个以上的变量](../code/ch03/item19.py)

unpacking 语法的作用之一是它允许 Python 函数返回多个值。

假设正在尝试确定鳄鱼种群的各种统计数据。给定一个长度列表，需要计算总体中的最小和最大长度。

```python
>>> def get_stats(numbers):
...     minimum = min(numbers)
...     maximum = max(numbers)
...     return minimum, maximum
...
>>>
>>> lengths = [63, 73, 72, 60, 67, 66, 71, 61, 72, 70]
>>> 
>>> minimum, maximum = get_stats(lengths)  # Two return values
>>> print(f"Min: {minimum}, Max: {maximum}")
Min: 60, Max: 73
>>>
```

其工作方式是将多个值一起返回到一个包含两项的元组中。然后，调用代码通过分配两个变量来拆解返回的元组。

在返回多个值的时候，可以用带星号的表达式接收那些没有被普通变量捕获的值。比如需要计算每条鳄鱼占平均值的比例，需要知道最大和最小的比例。

```python
>>> lengths = [63, 73, 72, 60, 67, 66, 71, 61, 72, 70]
>>> def get_avg_ratio(numbers):
...     average = sum(numbers) / len(numbers)
...     scaled = [x / average for x in numbers]
...     scaled.sort(reverse=True)
...     return scaled
... 
>>>
>>> longest, *middle, shortest = get_avg_ratio(lengths)
>>> print(f"Longest:  {longest:>4.0%}")
Longest:  108%
>>> print(f"Shortest: {shortest:>4.0%}")
Shortest:  89%
>>>
```

假设现在需要返回描述性统计的那些值，

```python
>>> def get_stats(numbers):
...     minimum = min(numbers)
...     maximum = max(numbers)
...     count = len(numbers)
...     average = sum(numbers) / count
...     sorted_numbers = sorted(numbers)
...     middle = count // 2
...     if count % 2:
...         median = sorted_numbers[middle]
...     else:
...         lower = sorted_numbers[middle - 1]
...         upper = sorted_numbers[middle]
...         median = (lower + upper) / 2
...     return minimum, maximum, average, median, count
...
>>> minimum, maximum, average, median, count = get_stats(lengths)
>>> print(f"Min: {minimum}, Max: {maximum}")
Min: 60, Max: 73
>>> print(f"Average: {average}, Median: {median}, Count: {count}")
Average: 67.5, Median: 68.5, Count: 10
>>>
```

这样写的代码有两个问题：

1. 很容易搞错顺序，而导致使用错误的数据，比如说本来中位数变成了平均值
2. 如果接收的变量很多，根据 PEP8 风格指南，那么很可能会导致代码换行，这会是的代码阅读起来不方便

```python
# Correct:
minimum, maximum, average, median, count = get_stats(lengths)

# Oops! Median and average swapped:
minimum, maximum, median, average, count = get_stats(lengths)
```

```python
minimum, maximum, average, median, count = get_stats(
    lengths)

minimum, maximum, average, median, count = \
    get_stats(lengths)
(minimum, maximum, average, 
 median, count) = get_stats(lengths)
(minimum, maximum, average, median, count
 ) = get_stats(lengths)
```

为了避免这些问题，在从函数中解包多个返回值时，切勿使用超过三个变量。一个三元素的元组最多拆解三个变量，或两个变量与一个万能变量（带星号的变量）。如果需要拆包比这更多的返回值，最好定义一个轻量级类或 `namedtuple` 并让函数返回一个实例那个。

> 小结
>
> 1. 可以让函数返回多个值，方法是将它们放入元组中并让调用者利用 Python 的 unpacking 语法。
> 2. 函数的多个返回值也可以通过带星号表达式来解包，这样没有被捕获的变量全部都在星号变量中。
> 3. 解包为四个或更多变量很容易出错，应该避免；可以返回一个类或 `namedtuple` 实例来替代。

## [第 20 项：遇到意外情况时应该抛出异常，不要返回 None](../code/ch03/item20.py)

在编写工具函数时，Python 程序员倾向于为 `None` 的返回值赋予特殊含义。对于某些函数，这或许有些道理。

```python
>>> def careful_divide(a, b):
...     try:
...         return a / b
...     except ZeroDivisionError:
...         return None
... 
>>>
>>> x, y = 1, 0
>>> result = careful_divide(x, y)
>>> if result is None:
...     print("Invalid inputs")
...
Invalid inputs
>>>
```

问题在于如果我这里不写 `result is None`，而是直接 `not result`，那么很多值在 Python 都可以被判断为 False，这里的情型时，如果被除数是 0，那么程序就会判断为无效输入，这是完全不合理的。

```python
>>> x, y = 0, 5
>>> result = careful_divide(x, y)
>>> if not result:
...     print("Invalid inputs")
...
Invalid inputs
>>>
```

当 `None` 具有特殊含义时，这种对 False 等效返回值的误解是 Python 代码中的常见错误。有两种方法可以减少出现此类错误的可能性。

第一种方法是将返回值拆分为二元组。元组的第一部分指示操作是成功还是失败。第二部分是计算的实际结果：

```python
>>> def careful_divide(a, b):
...     try:
...         return True, a / b
...     except ZeroDivisionError:
...         return False, None
...
>>> 
>>> success, result = careful_divide(x, y)
>>> if not success:
...     print("Invalid inputs")
...
>>>
```

这带来的问题是调用者可以轻松忽略元组的第一部分（使用 `_`，这是未使用变量的 Python 约定）。

```python
_, result = careful_divide(x, y)
if not result:
    print("Invalid inputs")
```

第二种更好的方法是在特殊情况下永远不返回 `None`。而是向调用者引发异常并让调用者处理它。在这里，我将 `ZeroDivisionError` 转换为 `ValueError` 来向调用者指示输入值不正确：

```python
>>> def careful_divide(a, b):
...     try:
...         return a / b
...     except ZeroDivisionError:
...         raise ValueError("Invalid inputs")
...
>>>
>>> x, y = 5, 2
>>> try:
...     result = careful_divide(x, y)
... except ValueError:
...     print("Invalid inputs")
... else:
...     print(f"Result is {result:.1f}")
...
Result is 2.5
>>>
```

调用者不再需要判断函数返回值。相反，它可以假设返回值始终有效，并在 `try` 之后立即在 `else` 块中使用结果。

> 要点
>
>1. 返回 `None` 来指示特殊含义的函数很容易出错，因为 `None` 和其他值（例如零、空字符串）在条件表达式中都计算为 `False`。
>2. 用引发异常来指示特殊情况，而不是返回 `None`。让调用的代码根据文档中写明的异常能够正确处理异常。

```python
def careful_divide(a: float, b: float) -> float:
    """Divides a by b.

    Raises
    ------
    `ValueError`
        When the inputs cannot be divided.
    """
    try:
        return a / b
    except ZeroDivisionError:
        raise ValueError("Invalid inputs")
```
