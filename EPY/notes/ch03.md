# 函数

程序员在 Python 中使用的第一个组织工具是**函数**（function）。

## [第 19 项：当函数返回多个值时，切勿拆分三个以上的变量](../code/ch03/item19.py)

unpacking 语法的作用之一是它允许 Python 函数返回多个值。

假设正在尝试确定鳄鱼种群的各种统计数据。给定一个长度列表，需要计算总体中的最小和最大长度。

```python
>>> def get_stats(numbers):
...     minimum = min(numbers)
...     maximum = max(numbers)
...     return minimum, maximum
...
>>>
>>> lengths = [63, 73, 72, 60, 67, 66, 71, 61, 72, 70]
>>> 
>>> minimum, maximum = get_stats(lengths)  # Two return values
>>> print(f"Min: {minimum}, Max: {maximum}")
Min: 60, Max: 73
>>>
```

其工作方式是将多个值一起返回到一个包含两项的元组中。然后，调用代码通过分配两个变量来拆解返回的元组。

在返回多个值的时候，可以用带星号的表达式接收那些没有被普通变量捕获的值。比如需要计算每条鳄鱼占平均值的比例，需要知道最大和最小的比例。

```python
>>> lengths = [63, 73, 72, 60, 67, 66, 71, 61, 72, 70]
>>> def get_avg_ratio(numbers):
...     average = sum(numbers) / len(numbers)
...     scaled = [x / average for x in numbers]
...     scaled.sort(reverse=True)
...     return scaled
... 
>>>
>>> longest, *middle, shortest = get_avg_ratio(lengths)
>>> print(f"Longest:  {longest:>4.0%}")
Longest:  108%
>>> print(f"Shortest: {shortest:>4.0%}")
Shortest:  89%
>>>
```

假设现在需要返回描述性统计的那些值，

```python
>>> def get_stats(numbers):
...     minimum = min(numbers)
...     maximum = max(numbers)
...     count = len(numbers)
...     average = sum(numbers) / count
...     sorted_numbers = sorted(numbers)
...     middle = count // 2
...     if count % 2:
...         median = sorted_numbers[middle]
...     else:
...         lower = sorted_numbers[middle - 1]
...         upper = sorted_numbers[middle]
...         median = (lower + upper) / 2
...     return minimum, maximum, average, median, count
...
>>> minimum, maximum, average, median, count = get_stats(lengths)
>>> print(f"Min: {minimum}, Max: {maximum}")
Min: 60, Max: 73
>>> print(f"Average: {average}, Median: {median}, Count: {count}")
Average: 67.5, Median: 68.5, Count: 10
>>>
```

这样写的代码有两个问题：

1. 很容易搞错顺序，而导致使用错误的数据，比如说本来中位数变成了平均值
2. 如果接收的变量很多，根据 PEP8 风格指南，那么很可能会导致代码换行，这会是的代码阅读起来不方便

```python
# Correct:
minimum, maximum, average, median, count = get_stats(lengths)

# Oops! Median and average swapped:
minimum, maximum, median, average, count = get_stats(lengths)
```

```python
minimum, maximum, average, median, count = get_stats(
    lengths)

minimum, maximum, average, median, count = \
    get_stats(lengths)
(minimum, maximum, average, 
 median, count) = get_stats(lengths)
(minimum, maximum, average, median, count
 ) = get_stats(lengths)
```

为了避免这些问题，在从函数中解包多个返回值时，切勿使用超过三个变量。一个三元素的元组最多拆解三个变量，或两个变量与一个万能变量（带星号的变量）。如果需要拆包比这更多的返回值，最好定义一个轻量级类或 `namedtuple` 并让函数返回一个实例那个。

> 小结
>
> 1. 可以让函数返回多个值，方法是将它们放入元组中并让调用者利用 Python 的 unpacking 语法。
> 2. 函数的多个返回值也可以通过带星号表达式来解包，这样没有被捕获的变量全部都在星号变量中。
> 3. 解包为四个或更多变量很容易出错，应该避免；可以返回一个类或 `namedtuple` 实例来替代。

## [第 20 项：遇到意外情况时应该抛出异常，不要返回 None](../code/ch03/item20.py)

在编写工具函数时，Python 程序员倾向于为 `None` 的返回值赋予特殊含义。对于某些函数，这或许有些道理。

```python
>>> def careful_divide(a, b):
...     try:
...         return a / b
...     except ZeroDivisionError:
...         return None
... 
>>>
>>> x, y = 1, 0
>>> result = careful_divide(x, y)
>>> if result is None:
...     print("Invalid inputs")
...
Invalid inputs
>>>
```

问题在于如果我这里不写 `result is None`，而是直接 `not result`，那么很多值在 Python 都可以被判断为 False，这里的情型时，如果被除数是 0，那么程序就会判断为无效输入，这是完全不合理的。

```python
>>> x, y = 0, 5
>>> result = careful_divide(x, y)
>>> if not result:
...     print("Invalid inputs")
...
Invalid inputs
>>>
```

当 `None` 具有特殊含义时，这种对 False 等效返回值的误解是 Python 代码中的常见错误。有两种方法可以减少出现此类错误的可能性。

第一种方法是将返回值拆分为二元组。元组的第一部分指示操作是成功还是失败。第二部分是计算的实际结果：

```python
>>> def careful_divide(a, b):
...     try:
...         return True, a / b
...     except ZeroDivisionError:
...         return False, None
...
>>> 
>>> success, result = careful_divide(x, y)
>>> if not success:
...     print("Invalid inputs")
...
>>>
```

这带来的问题是调用者可以轻松忽略元组的第一部分（使用 `_`，这是未使用变量的 Python 约定）。

```python
_, result = careful_divide(x, y)
if not result:
    print("Invalid inputs")
```

第二种更好的方法是在特殊情况下永远不返回 `None`。而是向调用者引发异常并让调用者处理它。在这里，我将 `ZeroDivisionError` 转换为 `ValueError` 来向调用者指示输入值不正确：

```python
>>> def careful_divide(a, b):
...     try:
...         return a / b
...     except ZeroDivisionError:
...         raise ValueError("Invalid inputs")
...
>>>
>>> x, y = 5, 2
>>> try:
...     result = careful_divide(x, y)
... except ValueError:
...     print("Invalid inputs")
... else:
...     print(f"Result is {result:.1f}")
...
Result is 2.5
>>>
```

调用者不再需要判断函数返回值。相反，它可以假设返回值始终有效，并在 `try` 之后立即在 `else` 块中使用结果。

> 要点
>
>1. 返回 `None` 来指示特殊含义的函数很容易出错，因为 `None` 和其他值（例如零、空字符串）在条件表达式中都计算为 `False`。
>2. 用引发异常来指示特殊情况，而不是返回 `None`。让调用的代码根据文档中写明的异常能够正确处理异常。

```python
def careful_divide(a: float, b: float) -> float:
    """Divides a by b.

    Raises
    ------
    `ValueError`
        When the inputs cannot be divided.
    """
    try:
        return a / b
    except ZeroDivisionError:
        raise ValueError("Invalid inputs")
```

## [第 21 项：了解如何在闭包里面使用外层作用域中的元素](../code/ch03/item21.py)

假设想要对数字列表进行排序，但优先将一组数字排在第一位。当渲染用户界面并希望在其他所有内容之前显示重要消息或异常事件时，此模式非常有用。

执行此操作的常见方法是将辅助函数作为 `key` 参数传递给列表的排序方法。辅助函数的返回值将用作对列表中每个项目进行排序的值，可以检查给定的项目是否在重要组中，并可以相应地改变排序值：

```python
>>> def sort_priority(values, group):
...     def helper(x):
...         if x in group:
...             return (0, x)
...         return (1, x)
...     values.sort(key=helper)
...
>>> numbers = [8, 3, 1, 2, 5, 4, 7, 6]
>>> group = {2, 3, 5, 7}
>>> sort_priority(numbers, group)
>>> print(numbers)
[2, 3, 5, 7, 1, 4, 6, 8]
>>>
```

该函数按预期运行有以下三个原因：

1. Python 支持闭包，这让定义在外层函数内的内层函数可以访问外层函数的变量。这就是辅助函数 `sort_priority` 能够访问 `group` 参数的原因。
2. 函数是 Python 中的头等对象，这意味着可以直接引用它们、将它们分配给变量、将它们作为参数传递给其他函数、在表达式和 `if` 语句中比较它们等等。这就是 `sort` 接受闭包函数作为 `key` 参数的方式。
3. Python 对于比较序列（包括元组）有特定的规则。它首先比较索引为 0 的项；然后，如果它们相等，则比较索引 1 处的项；如果它们仍然相等，则会比较索引 2 处的项，依此类推。

如果 `sort_priority` 能够返回是否找到了更高优先级的项，那就太好了，这样用户界面代码就可以采取相应的行动。添加这样的行为似乎很简单，因为已经有一个闭包函数来决定每个数字属于哪个优先级。

```python
>>> def sort_priority2(numbers, group):
...     found = False
...     def helper(x):
...         if x in group:
...             found = True
...             return (0, x)
...         return (1, x)
...     numbers.sort(key=helper)
...     return found
...
>>> found = sort_priority2(numbers, group)
>>> assert not found
>>> print(numbers)
[2, 3, 5, 7, 1, 4, 6, 8]
>>>
```

排序的结果是没有问题的，但是返回 `found` 变量却是 `False`。当表达式中引用变量时，Python 解释器会遍历作用域以按以下顺序解析引用：

1. 当前函数的范围。
2. 任何封闭范围（例如其他包含函数）。
3. 包含代码的模块的作用域（也称为全局作用域， `global`）。
4. 内置作用域（包含 len 和 str 等函数， built-in）。

如果都没找，那么就会抛出 `NameError`。

但是为变量赋值的方式与变量的引用不同，如果该变量已在当前作用域中定义，则它将采用新值。 如果当前作用域中不存在该变量，Python 会将赋值视为变量定义。至关重要的是，新定义的变量的范围近是包含赋值的函数。

此赋值行为解释了 `sort_priority2` 函数的错误返回值。变量 `found` 在 `helper` 中被赋值为 True。闭包的赋值被视为在 `helper` 中的新变量定义，而不是 `sort_priority2` 中的赋值，即使 `sort_priority2` 有 `found` 变量。

```python
def sort_priority2(numbers, group):
    found = False  # Scope: 'sort_priority2'

    def helper(x):
        if x in group:
            found = True  # Scope: 'helper' -- Bad!
            return (0, x)
        return (1, x)

    numbers.sort(key=helper)
    return found
```

这个问题有时被称为作用域 bug(scoping bug)，因为它可能会让人感到惊讶。但这种行为是符合预期的：它防止函数中的局部变量污染包含它的模块。

在 Python 中，有一种特殊的语法可以从闭包中获取数据。`nonlocal` 语句用于指示在为特定变量名赋值时应进行范围遍历。唯一的限制是 `nonlocal` 不会遍历到模块级范围（以避免污染 `global`）。

```python
def sort_priority3(numbers, group):
    found = False

    def helper(x):
        nonlocal found  # Added
        if x in group:
            found = True
            return (0, x)
        return (1, x)

    numbers.sort(key=helper)
    return found
```

`nonlocal` 语句清楚地表明数据何时从闭包分配到另一个范围。它是 `global` 的补充，`global` 指示变量的赋值应该直接进入模块范围。

**然而，就像全局变量的反模式一样，我不要将非局部用于简单函数之外的任何内容。**非局部的副作用可能很难理解。在长函数中尤其难以理解，因为非局部语句和关联变量的赋值相距甚远。

当 `nonlocal` 的使用开始变得复杂时，最好借助辅助类：

```python
class Sorter:
    def __init__(self, group) -> None:
        self.group = group
        self.found = False

    def __call__(self, x) -> Any:
        if x in self.group:
            self.found = True
            return (0, x)
        return (1, x)


sorter = Sorter(group)
numbers.sort(key=sorter)
# 有个问题，找到一次之后，就一直是 True
# 对不同的 numbers，每次都需要实例 Sorter
assert sorter.found is True
```

> 要点
>
>1. 闭包函数可以引用定义它们的外层作用域中的变量
>2. 默认情况下，闭包不能通过赋值变量来影响外层范围。
>3. 使用 `nonlocal` 语句来指示闭包何时可以修改其外层范围内的变量。
>4. 避免对简单函数之外的任何内容使用 `nonlocal` 语句。
